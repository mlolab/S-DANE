from haven import haven_utils as hu
import itertools 

EXP_GROUPS = {} 

# Convex quadratic minimization
opt_convex_adaptive = [
        {'name':'DANE+', 'max_epoch': 400, 
              'lr': 0.005, 
              'lambda_reguriz': 5, 
              'step_size_rule': 'constant',
              'activate_stopping_criterion': True,
              'control_variate': 1, 
              'averaging': 'standard', 
              'no_prob': True, 
              'batch_size_local_solver': 'full', 
              'batch_size_control_variate': 'full',
              'nb_clients_sampled': 5},

        {'name':'Adaptive S-DANE', 'max_epoch': 27, 
              'acceleration': False,
              'lr': 0.005, 
              'mu':0,
              'step_size_rule': 'constant',
              'lambda_reguriz': 1e-1, 
              'record_local_similarity': True,
              'record_local_smoothness': True,
              'lower_bound_lambda': False,
              'adaptive_lambda': True,
              'nb_local_steps': 10,
              'activate_stopping_criterion': True,
              'use_control_variate': True,
              'nb_clients_sampled': 'full',
              'batch_size_local_solver': 'full', 
              'batch_size_control_variate': 'full'}, 

        {'name':'Adaptive Acc-S-DANE', 'max_epoch': 34, 
              'acceleration': True,
              'lr': 0.005, 
              'mu':0,
              'step_size_rule': 'constant',
              'lambda_reguriz': 1e-1, 
              'record_local_similarity': True,
              'record_local_smoothness': True,
              'lower_bound_lambda': False,
              'adaptive_lambda': True,
              'nb_local_steps': 10,
              'activate_stopping_criterion': True,
              'use_control_variate': True,
              'nb_clients_sampled': 'full',
              'batch_size_local_solver': 'full', 
              'batch_size_control_variate': 'full'}, 

        {'name':'Acc-S-DANE', 'max_epoch': 400, 
              'acceleration': True,
              'lr': 0.005, 
              'mu':0,
              'step_size_rule': 'constant',
              'lambda_reguriz': 5, 
              'nb_local_steps': 20,
              'adaptive_lambda': False,
              'record_local_similarity': False,
              'record_local_smoothness': False,
              'activate_stopping_criterion': True,
              'use_control_variate': True,
              'nb_clients_sampled': 'full',
              'batch_size_local_solver': 'full', 
              'batch_size_control_variate': 'full'},


]
EXP_GROUPS['convex_adaptive'] = hu.cartesian_exp_group({"dataset":['quadratic'],
                                                        'convexity': ['convex'],
                                                        "n_samples":[50],
                                                        'd':[1000], 
                                                        "model":["quadratic_model"],
                                                        "loss_func": ['quadratic_loss'],
                                                        "acc_func": ["quadratic_acc"],
                                                        "split": ['iid'],
                                                        'nb_classes': [2],
                                                        'alpha': [1],
                                                        'nb_users': [5],
                                                        "opt": opt_convex_adaptive,
                                                        'batch_size_val_acc': 50,
                                                        'sigma2': [0],
                                                        'record_grad_norm': False,
                                                        "runs":[0]})



# ijcnn 

opt_ijcnn_noniid_adaptive = [
    
    {'name':'Adaptive S-DANE', 'max_epoch': 50, 
              'acceleration': False,
              'lr': 30, 
              'mu': 2.5e-5,
              'step_size_rule': 'constant',
              'lambda_reguriz': 1e-2, 
              'lower_bound_lambda': False,
              'record_local_similarity': True,
              'record_local_smoothness': True,
              'adaptive_lambda': True,
              'nb_local_steps': 10,
              'activate_stopping_criterion': True,
              'use_control_variate': True,
              'nb_clients_sampled': 'full',
              'batch_size_local_solver': 'full', 
              'batch_size_control_variate': 'full'},

     {'name':'Adaptive Acc-S-DANE', 'max_epoch': 50, 
              'acceleration': True,
              'lr': 30, 
              'mu': 2.5e-5,
              'step_size_rule': 'constant',
              'lambda_reguriz': 1e-2, 
              'lower_bound_lambda': False,
              'record_local_similarity': True,
              'record_local_smoothness': True,
              'adaptive_lambda': True,
              'nb_local_steps': 10,
              'activate_stopping_criterion': True,
              'use_control_variate': True,
              'nb_clients_sampled': 'full',
              'batch_size_local_solver': 'full', 
              'batch_size_control_variate': 'full'},

    {'name':'Fedprox', 'max_epoch': 50, 
              'lr': 50, 'lambda_reguriz': 1e-3, 
              'step_size_rule': 'constant',
              'nb_local_steps': 10,
              'activate_stopping_criterion': False,   
              'control_variate': 2, 
              'averaging': 'standard', 
              'no_prob': True,
              'batch_size_local_solver': 'full', 
              'batch_size_control_variate': 'full',
              'nb_clients_sampled': 10}, 

      {'name':'GD', 'max_epoch': 50, 'lr':100},

      {'name':'Scaffold', 'max_epoch': 50, 
              'lr': 50, 'lambda_reguriz': 0, 
              'step_size_rule': 'constant',
              'nb_local_steps': 10,
              'activate_stopping_criterion': False,   
              'control_variate': 1, 
              'averaging': 'standard', 
              'no_prob': True, 
              'batch_size_local_solver': 'full', 
              'batch_size_control_variate': 'full',
              'nb_clients_sampled': 10},

      {'name':'DANE+', 'max_epoch': 50, 
              'lr': 50, 'lambda_reguriz': 1e-3, 
              'step_size_rule': 'constant',
              'nb_local_steps': 10,
              'activate_stopping_criterion': False,   
              'control_variate': 1, 
              'averaging': 'standard', 
              'no_prob': True, 
              'batch_size_local_solver': 'full', 
              'batch_size_control_variate': 'full',
              'nb_clients_sampled': 10},
      
      {'name':'Scaffnew', 'max_epoch': 50, 
              'lr': 50, 'lambda_reguriz': 0, 
              'step_size_rule': 'constant',
              'nb_local_steps': 10,
              'activate_stopping_criterion': False,   
              'control_variate': 2, 
              'averaging': 'standard', 
              'no_prob': False,
              'p': 0.1, 
              'batch_size_local_solver': 'full', 
              'batch_size_control_variate': 'full',
              'nb_clients_sampled': 10},

]

EXP_GROUPS['ijcnn_noniid_adaptive'] = hu.cartesian_exp_group({"dataset":'ijcnn',
                                "model":["logistic_regression"],
                                "loss_func": ['logistic_loss'],
                                "acc_func": ["logistic_acc"],
                                "split": ['noniid'],
                                'nb_classes': [2],
                                'alpha': [1],
                                'nb_users': [10],
                                "opt": opt_ijcnn_noniid_adaptive,
                                'batch_size_val_acc': 64,
                                "record_grad_norm": True,
                                'sigma2': [2.5e-5],
                                "runs":[0]})


opt_ijcnn_iid_adaptive = [
    
     {'name':'Adaptive S-DANE', 'max_epoch': 13, 
              'acceleration': False,
              'lr': 30, 
              'mu': 2.5e-5,
              'step_size_rule': 'constant',
              'lambda_reguriz': 1e-4, 
              'lower_bound_lambda': False,
              'record_local_similarity': True,
              'record_local_smoothness': True,
              'adaptive_lambda': True,
              'nb_local_steps': 10,
              'activate_stopping_criterion': True,
              'use_control_variate': True,
              'nb_clients_sampled': 'full',
              'batch_size_local_solver': 'full', 
              'batch_size_control_variate': 'full'},

     {'name':'Adaptive Acc-S-DANE', 'max_epoch': 15, 
              'acceleration': True,
              'lr': 30, 
              'mu': 2.5e-5,
              'step_size_rule': 'constant',
              'lambda_reguriz': 1e-4, 
              'lower_bound_lambda': False,
              'record_local_similarity': True,
              'record_local_smoothness': True,
              'adaptive_lambda': True,
              'nb_local_steps': 10,
              'activate_stopping_criterion': True,
              'use_control_variate': True,
              'nb_clients_sampled': 'full',
              'batch_size_local_solver': 'full', 
              'batch_size_control_variate': 'full'},

      {'name':'Fedprox', 'max_epoch': 50, 
              'lr': 50, 'lambda_reguriz': 1e-3, 
              'step_size_rule': 'constant',
              'nb_local_steps': 10,
              'activate_stopping_criterion': False,   
              'control_variate': 2, 
              'averaging': 'standard', 
              'no_prob': True,
              'batch_size_local_solver': 'full', 
              'batch_size_control_variate': 'full',
              'nb_clients_sampled': 10}, 

      {'name':'GD', 'max_epoch': 50, 'lr':100},

      {'name':'Scaffold', 'max_epoch': 50, 
              'lr': 100, 'lambda_reguriz': 0, 
              'step_size_rule': 'constant',
              'nb_local_steps': 10,
              'activate_stopping_criterion': False,   
              'control_variate': 1, 
              'averaging': 'standard', 
              'no_prob': True, 
              'batch_size_local_solver': 'full', 
              'batch_size_control_variate': 'full',
              'nb_clients_sampled': 10},

      {'name':'DANE+', 'max_epoch': 50, 
              'lr': 100, 'lambda_reguriz': 1e-4, 
              'step_size_rule': 'constant',
              'nb_local_steps': 10,
              'activate_stopping_criterion': False,   
              'control_variate': 1, 
              'averaging': 'standard', 
              'no_prob': True, 
              'batch_size_local_solver': 'full', 
              'batch_size_control_variate': 'full',
              'nb_clients_sampled': 10},
      
      {'name':'Scaffnew', 'max_epoch': 50, 
              'lr': 100, 'lambda_reguriz': 0, 
              'step_size_rule': 'constant',
              'nb_local_steps': 10,
              'activate_stopping_criterion': False,   
              'control_variate': 2, 
              'averaging': 'standard', 
              'no_prob': False,
              'p': 0.1, 
              'batch_size_local_solver': 'full', 
              'batch_size_control_variate': 'full',
              'nb_clients_sampled': 10},

]

EXP_GROUPS['ijcnn_iid_adaptive'] = hu.cartesian_exp_group({"dataset":'ijcnn',
                                "model":["logistic_regression"],
                                "loss_func": ['logistic_loss'],
                                "acc_func": ["logistic_acc"],
                                "split": ['iid'],
                                'nb_classes': [2],
                                'alpha': [1],
                                'nb_users': [10],
                                "opt": opt_ijcnn_iid_adaptive,
                                'batch_size_val_acc': 64,
                                "record_grad_norm": True,
                                'sigma2': [2.5e-5],
                                "runs":[0]})


# polyhedron problems

opt_polyhedron = [
        {'name':'S-DANE', 'max_epoch': 100, 
                'acceleration': False,
                'lr': 0.8, 
                'mu': 0.1,
                'nb_local_steps': 10,
                'step_size_rule': 'constant',
                'lambda_reguriz': 0.1, 
                'adaptive_lambda': False,
                'activate_stopping_criterion': True,
                'use_control_variate': True,
                'nb_clients_sampled': 10,
                'batch_size_local_solver': 'full', 
                'batch_size_control_variate': 'full'},

        {'name':'Acc-S-DANE', 'max_epoch': 100, 
                'acceleration': True,
                'lr': 0.8, 
                'mu': 0.1,
                'adaptive_lambda': False,
                'step_size_rule': 'constant',
                'lambda_reguriz': 0.1, 
                'nb_local_steps': 10,
                'activate_stopping_criterion': False,
                'use_control_variate': True,
                'nb_clients_sampled': 10,
                'batch_size_local_solver': 'full', 
                'batch_size_control_variate': 'full'},

        {'name':'AccGradSliding', 'max_epoch': 100, 
                'lr': 0.1, 
                # lr > 0.1, the algorithm explodes
                'mu':0.1,
                'adaptive_lambda': False,
                'step_size_rule': 'constant',
                'lambda_reguriz': 0.1, 
                'nb_local_steps': 10,
                "idx_comp": 0,
                'use_control_variate': True,
                'activate_stopping_criterion': False,
                'nb_clients_sampled': 10,
                'batch_size_local_solver': 'full', 
                'batch_size_control_variate': 'full'},

        {'name':'Scaffold', 'max_epoch': 100, 
                'lr': 0.5, 'lambda_reguriz': 0, 
                'step_size_rule': 'constant',
                'nb_local_steps': 10,
                'activate_stopping_criterion': False,   
                'control_variate': 1, 
                'averaging': 'standard', 
                'no_prob': True, 
                'batch_size_local_solver': 'full', 
                'batch_size_control_variate': 'full',
                'nb_clients_sampled': 10},

        {'name':'Scaffnew', 'max_epoch': 100, 
                'lr': 0.3, 'lambda_reguriz': 0, 
                'step_size_rule': 'constant',
                'nb_local_steps': 10,
                'activate_stopping_criterion': False,   
                'control_variate': 2, 
                'averaging': 'standard', 
                'no_prob': False,
                'p': 0.12, 
                'batch_size_local_solver': 'full', 
                'batch_size_control_variate': 'full',
                'nb_clients_sampled': 10},

        {'name':'GD', 'lr':1,'max_epoch': 100},

        {'name':'Fedprox', 'max_epoch': 100, 
                'lr': 0.5, 'lambda_reguriz': 1e-1, 
                'step_size_rule': 'constant',
                'nb_local_steps': 10,
                'activate_stopping_criterion': False,   
                'control_variate': 0, 
                'averaging': 'standard', 
                'no_prob': True,
                'batch_size_local_solver': 'full', 
                'batch_size_control_variate': 'full',
                'nb_clients_sampled': 10}, 

        {'name':'DANE+', 'max_epoch': 100, 
                'lr': 0.5, 'lambda_reguriz': 1e-1, 
                'step_size_rule': 'constant',
                'nb_local_steps': 10,
                'activate_stopping_criterion': False,   
                'control_variate': 1, 
                'averaging': 'standard', 
                'no_prob': True, 
                'batch_size_local_solver': 'full', 
                'batch_size_control_variate': 'full',
                'nb_clients_sampled': 10},
       
]

EXP_GROUPS['polyhedron'] = hu.cartesian_exp_group({"dataset":'polyhedron_dataset',
                                "nb_samples": 10000,
                                "d": 1000,
                                "model":["polyhedron_linear_model"],
                                "loss_func": ['polyhedron_loss'],
                                "acc_func": ["polyhedron_loss"],
                                "opt": opt_polyhedron,
                                'R': 1000000,
                                'sigma2': [0],
                                "record_grad_norm": False,
                                "split": ['iid'],
                                'nb_classes': [2],
                                'alpha': [1],
                                'batch_size_val_acc': 512,
                                'nb_users': [10],
                                "runs":[0]})

 


opt_polyhedron_sample1 = [
     {'name':'S-DANE', 'max_epoch': 400, 
              'acceleration': False,
              'lr': 0.1, 
              'mu':0.1,
              'nb_local_steps': 10,
              'step_size_rule': 'constant',
              'lambda_reguriz': 0.1, 
              'adaptive_lambda': False,
              'activate_stopping_criterion': False,
              'use_control_variate':True,
              'nb_clients_sampled': 10,
              'batch_size_local_solver': 'full', 
              'batch_size_control_variate': 'full'},

      {'name':'Acc-S-DANE', 'max_epoch': 400, 
              'acceleration': True,
              'lr': 0.1, 
              'mu':0.1,
              'adaptive_lambda': False,
              'step_size_rule': 'constant',
              'lambda_reguriz': 0.1, 
              'nb_local_steps': 10,
              'activate_stopping_criterion': False,
              'use_control_variate': True,
              'nb_clients_sampled': 10,
              'batch_size_local_solver': 'full', 
              'batch_size_control_variate': 'full'},
    
      {'name':'Scaffold', 'max_epoch': 400, 
              'lr': 0.3, 'lambda_reguriz': 0, 
              'step_size_rule': 'constant',
              'nb_local_steps': 10,
              'activate_stopping_criterion': False,   
              'control_variate': 1, 
              'averaging': 'standard', 
              'no_prob': True, 
              'batch_size_local_solver': 'full', 
              'batch_size_control_variate': 'full',
              'nb_clients_sampled': 10},

        {'name':'Fedprox', 'max_epoch': 400, 
              'lr': 0.5, 'lambda_reguriz': 1e-1, 
              'step_size_rule': 'constant',
              'nb_local_steps': 10,
              'activate_stopping_criterion': False,   
              'control_variate': 0, 
              'averaging': 'standard', 
              'no_prob': True,
              'batch_size_local_solver': 'full', 
              'batch_size_control_variate': 'full',
              'nb_clients_sampled': 10}, 
]

EXP_GROUPS['polyhedron_sample1'] = hu.cartesian_exp_group({"dataset":'polyhedron_dataset',
                                "nb_samples": 10000,
                                "d": 1000,
                                "model":["polyhedron_linear_model"],
                                "loss_func": ['polyhedron_loss'],
                                "acc_func": ["polyhedron_loss"],
                                "opt": opt_polyhedron_sample1,
                                'R': 1000000,
                                'sigma2': [0],
                                "record_grad_norm": False,
                                "split": ['iid'],
                                'nb_classes': [2],
                                'alpha': [1],
                                'batch_size_val_acc': 512,
                                'nb_users': [100],
                                "runs":[0]})
                              


opt_polyhedron_sample2 = [
    {'name':'S-DANE', 'max_epoch': 200, 
              'acceleration': False,
              'lr': 0.1, 
              'mu':0.1,
              'nb_local_steps': 10,
              'step_size_rule': 'constant',
              'lambda_reguriz': 0.1, 
              'adaptive_lambda': False,
              'activate_stopping_criterion': False,
              'use_control_variate':True,
              'nb_clients_sampled': 40,
              'batch_size_local_solver': 'full', 
              'batch_size_control_variate': 'full'},

    {'name':'Acc-S-DANE', 'max_epoch': 200, 
              'acceleration': True,
              'lr': 0.1, 
              'mu':0.1,
              'adaptive_lambda': False,
              'step_size_rule': 'constant',
              'lambda_reguriz': 0.1, 
              'nb_local_steps': 10,
              'activate_stopping_criterion': False,
              'use_control_variate': True,
              'nb_clients_sampled': 40,
              'batch_size_local_solver': 'full', 
              'batch_size_control_variate': 'full'},

        
     {'name':'Scaffold', 'max_epoch': 200, 
              'lr': 0.3, 'lambda_reguriz': 0, 
              'step_size_rule': 'constant',
              'nb_local_steps': 10,
              'activate_stopping_criterion': False,   
              'control_variate': 1, 
              'averaging': 'standard', 
              'no_prob': True, 
              'batch_size_local_solver': 'full', 
              'batch_size_control_variate': 'full',
              'nb_clients_sampled': 40},

        {'name':'Fedprox', 'max_epoch': 200, 
              'lr': 0.5, 'lambda_reguriz': 1e-1, 
              'step_size_rule': 'constant',
              'nb_local_steps': 10,
              'activate_stopping_criterion': False,   
              'control_variate': 0, 
              'averaging': 'standard', 
              'no_prob': True,
              'batch_size_local_solver': 'full', 
              'batch_size_control_variate': 'full',
              'nb_clients_sampled': 40}, 

]

EXP_GROUPS['polyhedron_sample2'] = hu.cartesian_exp_group({"dataset":'polyhedron_dataset',
                                "nb_samples": 10000,
                                "d": 1000,
                                "model":["polyhedron_linear_model"],
                                "loss_func": ['polyhedron_loss'],
                                "acc_func": ["polyhedron_loss"],
                                "opt": opt_polyhedron_sample2,
                                'R': 1000000,
                                'sigma2': [0],
                                "record_grad_norm": False,
                                "split": ['iid'],
                                'nb_classes': [2],
                                'alpha': [1],
                                'batch_size_val_acc': 512,
                                'nb_users': [100],
                                "runs":[0]})

opt_polyhedron_sample3 = [
    {'name':'S-DANE', 'max_epoch': 200, 
              'acceleration': False,
              'lr': 0.1, 
              'mu':0.1,
              'nb_local_steps': 10,
              'step_size_rule': 'constant',
              'lambda_reguriz': 0.1, 
              'adaptive_lambda': False,
              'activate_stopping_criterion': False,
              'use_control_variate':True,
              'nb_clients_sampled': 80,
              'batch_size_local_solver': 'full', 
              'batch_size_control_variate': 'full'},

    {'name':'Acc-S-DANE', 'max_epoch': 200, 
              'acceleration': True,
              'lr': 0.1, 
              'mu':0.1,
              'adaptive_lambda': False,
              'step_size_rule': 'constant',
              'lambda_reguriz': 0.1, 
              'nb_local_steps': 10,
              'activate_stopping_criterion': False,
              'use_control_variate': True,
              'nb_clients_sampled': 80,
              'batch_size_local_solver': 'full', 
              'batch_size_control_variate': 'full'},

     {'name':'Scaffold', 'max_epoch': 200, 
              'lr': 0.3, 'lambda_reguriz': 0, 
              'step_size_rule': 'constant',
              'nb_local_steps': 10,
              'activate_stopping_criterion': False,   
              'control_variate': 1, 
              'averaging': 'standard', 
              'no_prob': True, 
              'batch_size_local_solver': 'full', 
              'batch_size_control_variate': 'full',
              'nb_clients_sampled': 80},

        {'name':'Fedprox', 'max_epoch': 200, 
              'lr': 0.5, 'lambda_reguriz': 1e-1, 
              'step_size_rule': 'constant',
              'nb_local_steps': 10,
              'activate_stopping_criterion': False,   
              'control_variate': 0, 
              'averaging': 'standard', 
              'no_prob': True,
              'batch_size_local_solver': 'full', 
              'batch_size_control_variate': 'full',
              'nb_clients_sampled': 80}, 

]

EXP_GROUPS['polyhedron_sample3'] = hu.cartesian_exp_group({"dataset":'polyhedron_dataset',
                                "nb_samples": 10000,
                                "d": 1000,
                                "model":["polyhedron_linear_model"],
                                "loss_func": ['polyhedron_loss'],
                                "acc_func": ["polyhedron_loss"],
                                "opt": opt_polyhedron_sample3,
                                'R': 1000000,
                                'sigma2': [0],
                                "record_grad_norm": False,
                                "split": ['iid'],
                                'nb_classes': [2],
                                'alpha': [1],
                                'batch_size_val_acc': 512,
                                'nb_users': [100],
                                "runs":[0]})


# cifar 10
opt_cifa10_sdane=[

        {'name':'S-DANE-nocv', 'max_epoch': 80, 
              'acceleration': False,
              'lr': 0.1, 
              'mu': 99/6,
              'a': 6,
              'step_size_rule': 'constant',
              'lambda_reguriz': 0.001, 
              'nb_local_steps': 70,
              'activate_stopping_criterion': False,
              'record_local_similarity': True,
              'record_local_smoothness': True,
              'adaptive_lambda': False,
              'use_control_variate': False,
              'epoch_start_control_variate': 0,
              'nb_clients_sampled': 'full',
              'batch_size_local_solver': 512, 
              'batch_size_control_variate': 'full',
              'nb_clients_sampled': 'full'}

]

EXP_GROUPS['cifar10_sdane'] = hu.cartesian_exp_group({"dataset":'cifar10',
                                "model":["resnet18_10"],
                                "loss_func": ['softmax_loss'],
                                "acc_func": ["softmax_accuracy"],
                                "split": ['noniid'],
                                'nb_classes': [10],
                                'alpha': [0.5],
                                'nb_users': [10],
                                "opt": opt_cifa10_sdane,
                                'batch_size_val_acc': 512,
                                'sigma2': [0],
                                'record_grad_norm':False,
                                "runs":[0]})